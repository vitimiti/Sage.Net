// -----------------------------------------------------------------------
// <copyright file="MemoryPoolGenerator.cs" company="Sage.Net">
// A transliteration and update of the CnC Generals (Zero Hour) engine and games with mod-first support.
// Copyright (C) 2025 Sage.Net Contributors
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program. If not, see https://www.gnu.org/licenses/.
// </copyright>
// -----------------------------------------------------------------------

using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Sage.Net.Generators.GameMemoryGenerator;

/// <summary>Generates code for a game memory pool.</summary>
[Generator]
public class MemoryPoolGenerator : IIncrementalGenerator
{
    /// <summary>Initializes the pool generator and calls the system to generate the glue code.</summary>
    /// <param name="context">The <see cref="IncrementalGeneratorInitializationContext"/> to use.</param>
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        IncrementalValuesProvider<INamedTypeSymbol?> classDeclarations = context
            .SyntaxProvider.CreateSyntaxProvider(
                predicate: static (s, _) => IsCandidate(s),
                transform: static (ctx, _) => GetSemanticTarget(ctx)
            )
            .Where(static m => m is not null);

        context.RegisterSourceOutput(
            classDeclarations,
            static (spc, classSymbol) => GenerateGlueCode(spc, classSymbol!)
        );
    }

    private static bool IsCandidate(SyntaxNode node) => node is ClassDeclarationSyntax { AttributeLists.Count: > 0 };

    private static INamedTypeSymbol? GetSemanticTarget(GeneratorSyntaxContext context)
    {
        var classDecl = (ClassDeclarationSyntax)context.Node;
        if (context.SemanticModel.GetDeclaredSymbol(classDecl) is not INamedTypeSymbol symbol)
        {
            return null;
        }

        INamedTypeSymbol? memoryPooledAttribute = context.SemanticModel.Compilation.GetTypeByMetadataName(
            "Sage.Net.MemoryPooledAttribute"
        );

#pragma warning disable IDE0046 // Convert to conditional expression
        if (memoryPooledAttribute is null)
#pragma warning restore IDE0046 //  Convert to conditional expression
        {
            return null;
        }

        return symbol
            .GetAttributes()
            .Any(a => SymbolEqualityComparer.Default.Equals(a.AttributeClass, memoryPooledAttribute))
            ? symbol
            : null;
    }

    private static void GenerateGlueCode(SourceProductionContext context, INamedTypeSymbol classSymbol)
    {
        var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();
        var className = classSymbol.Name;

        AttributeData? attribute = classSymbol
            .GetAttributes()
            .FirstOrDefault(ad => ad.AttributeClass?.Name is "MemoryPooledAttribute" or "MemoryPooled");

        if (attribute is null)
        {
            return;
        }

        var poolName = (string)attribute.ConstructorArguments[0].Value!;
        var initial = (int)attribute.ConstructorArguments[1].Value!;
        var overflow = (int)attribute.ConstructorArguments[2].Value!;

        var glue = $$"""
            // <auto-generated/>
            using Sage.Net.GameMemory;

            namespace {{namespaceName}}
            {
                public partial class {{className}}
                {
                    private static readonly MemoryPool<{{className}}> _classMemoryPool
                        = new MemoryPool<{{className}}>("{{poolName}}", {{initial}}, {{overflow}});

                    /// <summary>Allocates a new instance from the memory pool.</summary>
                    /// <returns>A new instance of <see cref="{{className}}"/>.</returns>
                    public static {{className}} New() => _classMemoryPool.Allocate();

                    /// <summary>Returns this instance to the memory pool.</summary>
                    public void Delete() => _classMemoryPool.Free(this);

                    /// <summary>Returns the static memory pool associated with this class.</summary>
                    /// <returns>The existing <see cref="MemoryPool{T}"/> of type <see cref="{{className}}"/>.</returns>
                    public static MemoryPool<{{className}}> GetClassMemoryPool() => _classMemoryPool;
                }
            }
            """;

        context.AddSource($"{className}_MemoryPool.g.cs", SourceText.From(glue, Encoding.UTF8));
    }
}
