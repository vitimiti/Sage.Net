// -----------------------------------------------------------------------
// <copyright file="TrigonometriInitializerGenerator.cs" company="Sage.Net">
// A transliteration and update of the CnC Generals (Zero Hour) engine and games with mod-first support.
// Copyright (C) 2025 Sage.Net Contributors
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program. If not, see https://www.gnu.org/licenses/.
// </copyright>
// -----------------------------------------------------------------------

using System.Diagnostics.CodeAnalysis;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace Sage.Net.Generators.TrigonometryTablesGenerator;

/// <summary>Generates the trigonometry table regenerator.</summary>
[Generator]
[SuppressMessage(
    "MicrosoftCodeAnalysisCorrectness",
    "RS1036:Specify analyzer banned API enforcement setting",
    Justification = "This is that case where we are doing advanced generators."
)]
public sealed class TrigonometryInitializerGenerator : IIncrementalGenerator
{
    /// <summary>Initializes the trigonometry initializer generator.</summary>
    /// <param name="context">The <see cref="IncrementalGeneratorInitializationContext"/> to use.</param>
    /// <remarks>The resulting code WILL BE CALLED ON MODULE INITIALIZATION. This only happens when the build property <c>RegenerateTrigonometryTables</c> is <see langword="true"/>.</remarks>
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        IncrementalValueProvider<bool> enabled = context.AnalyzerConfigOptionsProvider.Select(
            (provider, _) =>
                provider.GlobalOptions.TryGetValue("build_property.RegenerateTrigonometryTables", out var value)
                && string.Equals(value, "true", StringComparison.OrdinalIgnoreCase)
        );

        context.RegisterSourceOutput(
            enabled,
            (spc, isEnabled) =>
            {
                if (!isEnabled)
                {
                    return;
                }

                // Generate the actual lookup table *data* during compilation (source-gen time),
                // and emit it as normal C# code (no runtime file I/O required).
                var sinLookup = GenerateSinLookup();
                var arcCosLookup = GenerateArcCosLookup();

                var sinArrayInit = ToCSharpIntArrayInitializer(sinLookup, columns: 8, indent: "        ");
                var acosArrayInit = ToCSharpIntArrayInitializer(arcCosLookup, columns: 8, indent: "        ");

                var source = $$"""
                // <auto-generated />
                #nullable enable

                using System.Runtime.CompilerServices;

                namespace Sage.Net.TrigonometryTables;

                /// <summary>Build-generated trig tables.</summary>
                /// <remarks>This class is only produced when the MSBuild property <c>RegenerateTrigonometryTables</c> is <see langword="true"/>.</remarks>
                public static class TrigonometryTables
                {
                    internal const int TrigRes = 4096;
                    internal const int IntOne = 4096;

                    public static readonly int[] SinLookup = {{sinArrayInit}};

                    public static readonly int[] ArcCosLookup = {{acosArrayInit}};
                }

                internal static class __TrigAutoInit
                {
                    private static bool _initialized;

                    [ModuleInitializer]
                    internal static void Initialize()
                    {
                        if (_initialized)
                        {
                            return;
                        }

                        _initialized = true;

                        // Touch the tables to ensure type initialization happens immediately.
                        _ = TrigonometryTables.SinLookup.Length;
                        _ = TrigonometryTables.ArcCosLookup.Length;
                    }
                }

                """;

                spc.AddSource("TrigonometryTables.g.cs", SourceText.From(source, Encoding.UTF8));
            }
        );
    }

    private static int[] GenerateSinLookup()
    {
        const int trigRes = 4096;
        const int intOne = 4096;
        const double twoPi = 6.28318530718;

        var arr = new int[trigRes];
        for (var i = 0; i < trigRes; i++)
        {
            var angle = twoPi * i / trigRes;
            arr[i] = (int)(Math.Sin(angle) * intOne);
        }

        return arr;
    }

    private static int[] GenerateArcCosLookup()
    {
        const int intOne = 4096;
        const int intTwoPi = 25736;
        const double twoPi = 6.28318530718;

        var arr = new int[2 * intOne];
        for (var i = 0; i < 2 * intOne; i++)
        {
            var r = (i / (double)intOne) - 1.0;
            arr[i] = (int)(Math.Acos(r) * intTwoPi / twoPi);
        }

        return arr;
    }

    private static string ToCSharpIntArrayInitializer(int[] values, int columns, string indent)
    {
#pragma warning disable S125 // Sections of code should not be commented out
        // Produces:
        // new int[]
        // {
        //     0x00000000, 0x..., ...
        // };
#pragma warning restore S125 // Sections of code should not be commented out
        var sb = new StringBuilder(values.Length * 12);
        _ = sb.AppendLine("new int[]").AppendLine("    {");

        for (var i = 0; i < values.Length; i++)
        {
            if (i % columns == 0)
            {
                _ = sb.Append(indent);
            }

            _ = sb.Append(FormatHex32(values[i]));

            var isLast = i == values.Length - 1;
            if (!isLast)
            {
                _ = sb.Append(", ");
            }

            if ((i % columns == columns - 1) || isLast)
            {
                _ = sb.AppendLine();
            }
        }

        _ = sb.Append("    }");
        return sb.ToString();
    }

    private static string FormatHex32(int value) => $"0x{unchecked((uint)value):X8}";
}
